
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">classsphere-backend/auth/jwt.go (88.5%)</option>
				
				<option value="file1">classsphere-backend/auth/middleware.go (80.0%)</option>
				
				<option value="file2">classsphere-backend/auth/password.go (62.1%)</option>
				
				<option value="file3">classsphere-backend/cache/redis.go (100.0%)</option>
				
				<option value="file4">classsphere-backend/config/config.go (100.0%)</option>
				
				<option value="file5">classsphere-backend/database/database.go (71.9%)</option>
				
				<option value="file6">classsphere-backend/handlers/auth.go (86.1%)</option>
				
				<option value="file7">classsphere-backend/main.go (16.7%)</option>
				
				<option value="file8">classsphere-backend/models/user.go (63.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v4"
)

type Claims struct {
        UserID string `json:"user_id"`
        Role   string `json:"role"`
        jwt.StandardClaims
}

type JWTManager struct {
        secretKey []byte
}

func NewJWTManager(secretKey string) *JWTManager <span class="cov8" title="1">{
        return &amp;JWTManager{
                secretKey: []byte(secretKey),
        }
}</span>

func (j *JWTManager) GenerateToken(userID, role string, duration time.Duration) (string, error) <span class="cov8" title="1">{
        claims := &amp;Claims{
                UserID: userID,
                Role:   role,
                StandardClaims: jwt.StandardClaims{
                        Subject:   userID,
                        ExpiresAt: time.Now().Add(duration).Unix(),
                        IssuedAt:  time.Now().Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(j.secretKey)
}</span>

func (j *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov8" title="1">{
                        return nil, errors.New("unexpected signing method")
                }</span>
                <span class="cov8" title="1">return j.secretKey, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (j *JWTManager) RefreshToken(tokenString string, newDuration time.Duration) (string, error) <span class="cov8" title="1">{
        claims, err := j.GetTokenClaims(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return j.GenerateToken(claims.UserID, claims.Role, newDuration)</span>
}

func (j *JWTManager) GetTokenClaims(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("unexpected signing method")
                }</span>
                <span class="cov8" title="1">return j.secretKey, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok </span><span class="cov8" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token claims")</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"
)

// JWTMiddleware creates a JWT authentication middleware
func JWTMiddleware(jwtManager *JWTManager) echo.MiddlewareFunc <span class="cov8" title="1">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        // Get Authorization header
                        authHeader := c.Request().Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusUnauthorized, map[string]string{
                                        "error": "missing authorization header",
                                })
                        }</span>

                        // Check Bearer format (case insensitive)
                        <span class="cov8" title="1">parts := strings.Split(authHeader, " ")
                        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusUnauthorized, map[string]string{
                                        "error": "invalid authorization format",
                                })
                        }</span>

                        // Validate token
                        <span class="cov8" title="1">token := parts[1]
                        claims, err := jwtManager.ValidateToken(token)
                        if err != nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusUnauthorized, map[string]string{
                                        "error": "invalid token",
                                })
                        }</span>

                        // Set user context
                        <span class="cov8" title="1">c.Set("user", claims)

                        return next(c)</span>
                }
        }
}

// RequireRole creates a middleware that requires a specific role
func RequireRole(requiredRole string) echo.MiddlewareFunc <span class="cov8" title="1">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        // Get user from context
                        user := c.Get("user")
                        if user == nil </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusUnauthorized, map[string]string{
                                        "error": "user not authenticated",
                                })
                        }</span>

                        // Type assert to Claims
                        <span class="cov8" title="1">claims, ok := user.(*Claims)
                        if !ok </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusUnauthorized, map[string]string{
                                        "error": "invalid user context",
                                })
                        }</span>

                        // Check role
                        <span class="cov8" title="1">if claims.Role != requiredRole </span><span class="cov8" title="1">{
                                return c.JSON(http.StatusForbidden, map[string]string{
                                        "error": "insufficient permissions",
                                })
                        }</span>

                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// GetCurrentUser extracts the current user from the context
func GetCurrentUser(c echo.Context) (*Claims, bool) <span class="cov0" title="0">{
        user := c.Get("user")
        if user == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">claims, ok := user.(*Claims)
        return claims, ok</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "errors"
        "regexp"

        "golang.org/x/crypto/bcrypt"
)

// HashPassword creates a bcrypt hash of the password
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// CheckPassword verifies a password against its hash
func CheckPassword(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

// ValidatePasswordStrength checks if password meets security requirements
func ValidatePasswordStrength(password string) error <span class="cov8" title="1">{
        if len(password) &lt; 8 </span><span class="cov8" title="1">{
                return errors.New("password must be at least 8 characters long")
        }</span>

        <span class="cov8" title="1">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                return errors.New("password must be less than 128 characters long")
        }</span>

        // Check for at least one letter and one number
        <span class="cov8" title="1">hasLetter := regexp.MustCompile(`[a-zA-Z]`).MatchString(password)
        hasNumber := regexp.MustCompile(`[0-9]`).MatchString(password)

        if !hasLetter </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one letter")
        }</span>

        <span class="cov8" title="1">if !hasNumber </span><span class="cov8" title="1">{
                return errors.New("password must contain at least one number")
        }</span>

        // Check for common weak passwords
        <span class="cov8" title="1">weakPasswords := []string{
                "password", "123456", "password123", "admin", "qwerty",
                "letmein", "welcome", "monkey", "dragon", "password1",
        }

        lowercasePassword := regexp.MustCompile(`[A-Z]`).ReplaceAllString(password, "")
        for _, weak := range weakPasswords </span><span class="cov8" title="1">{
                if lowercasePassword == weak </span><span class="cov0" title="0">{
                        return errors.New("password is too common, please choose a stronger password")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GenerateRandomPassword generates a secure random password
func GenerateRandomPassword(length int) (string, error) <span class="cov0" title="0">{
        if length &lt; 8 </span><span class="cov0" title="0">{
                length = 8
        }</span>
        <span class="cov0" title="0">if length &gt; 128 </span><span class="cov0" title="0">{
                length = 128
        }</span>

        <span class="cov0" title="0">const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*"
        password := make([]byte, length)

        // This is a simplified random generation for testing
        // In production, use crypto/rand for secure random generation
        for i := range password </span><span class="cov0" title="0">{
                password[i] = charset[i%len(charset)]
        }</span>

        <span class="cov0" title="0">return string(password), nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package cache

import (
        "context"
        "time"

        "github.com/go-redis/redis/v8"
)

type RedisCache struct {
        client *redis.Client
}

type Cache interface {
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
        Get(ctx context.Context, key string) (string, error)
        Delete(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)
}

func NewRedisCache(client *redis.Client) *RedisCache <span class="cov8" title="1">{
        return &amp;RedisCache{
                client: client,
        }
}</span>

func (r *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov8" title="1">{
        return r.client.Set(ctx, key, value, expiration).Err()
}</span>

func (r *RedisCache) Get(ctx context.Context, key string) (string, error) <span class="cov8" title="1">{
        val, err := r.client.Get(ctx, key).Result()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

func (r *RedisCache) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        return r.client.Del(ctx, key).Err()
}</span>

func (r *RedisCache) Exists(ctx context.Context, key string) (bool, error) <span class="cov8" title="1">{
        count, err := r.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return count &gt; 0, nil</span>
}

func NewRedisClient(addr, password string, db int) *redis.Client <span class="cov8" title="1">{
        return redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })
}</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "os"
)

type Config struct {
        JWTSecret      string
        DatabasePath   string
        RedisAddr      string
        RedisPassword  string
        RedisDB        int
        GoogleClientID string
        GoogleSecret   string
        Port           string
}

func Load() *Config <span class="cov8" title="1">{
        return &amp;Config{
                JWTSecret:      getEnv("JWT_SECRET", "default-secret-key-for-development"),
                DatabasePath:   getEnv("DATABASE_PATH", "./classsphere.db"),
                RedisAddr:      getEnv("REDIS_ADDR", "localhost:6379"),
                RedisPassword:  getEnv("REDIS_PASSWORD", ""),
                RedisDB:        0,
                GoogleClientID: os.Getenv("GOOGLE_CLIENT_ID"),
                GoogleSecret:   os.Getenv("GOOGLE_SECRET"),
                Port:           getEnv("PORT", "8080"),
        }
}</span>

func getEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "classsphere-backend/models"
        "log"
        "os"
        "time"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// NewConnection creates a new database connection
func NewConnection(databasePath string) (*gorm.DB, error) <span class="cov8" title="1">{
        config := GetDatabaseConfig()
        db, err := gorm.Open(sqlite.Open(databasePath), config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Configure connection pool
        <span class="cov8" title="1">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set maximum number of open connections
        <span class="cov8" title="1">sqlDB.SetMaxOpenConns(25)
        // Set maximum number of idle connections
        sqlDB.SetMaxIdleConns(5)
        // Set maximum lifetime of connections
        sqlDB.SetConnMaxLifetime(5 * time.Minute)

        return db, nil</span>
}

// GetDatabaseConfig returns GORM configuration
func GetDatabaseConfig() *gorm.Config <span class="cov8" title="1">{
        logLevel := logger.Error
        if os.Getenv("APP_ENV") == "development" </span><span class="cov0" title="0">{
                logLevel = logger.Info
        }</span>

        <span class="cov8" title="1">return &amp;gorm.Config{
                Logger: logger.New(
                        log.New(os.Stdout, "\r\n", log.LstdFlags),
                        logger.Config{
                                SlowThreshold:             time.Second,
                                LogLevel:                  logLevel,
                                IgnoreRecordNotFoundError: true,
                                Colorful:                  true,
                        },
                ),
                NowFunc: func() time.Time </span><span class="cov8" title="1">{
                        return time.Now().UTC()
                }</span>,
        }
}

// AutoMigrate runs database migrations
func AutoMigrate(db *gorm.DB) error <span class="cov8" title="1">{
        return db.AutoMigrate(
                &amp;models.User{},
                // Add other models here as they're created
        )
}</span>

// InitializeDatabase creates connection and runs migrations
func InitializeDatabase(databasePath string) (*gorm.DB, error) <span class="cov8" title="1">{
        db, err := NewConnection(databasePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = AutoMigrate(db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}

// CloseDatabase closes the database connection
func CloseDatabase(db *gorm.DB) error <span class="cov8" title="1">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return sqlDB.Close()</span>
}

// HealthCheck performs a database health check
func HealthCheck(db *gorm.DB) error <span class="cov0" title="0">{
        sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqlDB.Ping()</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"
        "regexp"
        "strconv"
        "time"

        "classsphere-backend/auth"
        "classsphere-backend/models"

        "github.com/labstack/echo/v4"
)

// AuthHandler handles authentication-related requests
type AuthHandler struct {
        userRepo   *models.UserRepository
        jwtManager *auth.JWTManager
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(userRepo *models.UserRepository, jwtManager *auth.JWTManager) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                userRepo:   userRepo,
                jwtManager: jwtManager,
        }
}</span>

// Request/Response types
type RegisterRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=8"`
        Name     string `json:"name" validate:"required"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type RefreshTokenRequest struct {
        Token string `json:"token" validate:"required"`
}

type UserResponse struct {
        ID       uint   `json:"id"`
        Email    string `json:"email"`
        Name     string `json:"name"`
        Role     string `json:"role"`
        IsActive bool   `json:"is_active"`
}

type RegisterResponse struct {
        User  UserResponse `json:"user"`
        Token string       `json:"token"`
}

type LoginResponse struct {
        User  UserResponse `json:"user"`
        Token string       `json:"token"`
}

type RefreshTokenResponse struct {
        Token string `json:"token"`
}

type ErrorResponse struct {
        Error string `json:"error"`
}

// Register handles user registration
func (h *AuthHandler) Register(c echo.Context) error <span class="cov8" title="1">{
        var req RegisterRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request format"})
        }</span>

        // Validate input
        <span class="cov8" title="1">if err := h.validateRegisterRequest(req); err != nil </span><span class="cov8" title="1">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
        }</span>

        // Check if user already exists
        <span class="cov8" title="1">existingUser, err := h.userRepo.GetUserByEmail(req.Email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov8" title="1">{
                return c.JSON(http.StatusConflict, ErrorResponse{Error: "User with this email already exists"})
        }</span>

        // Hash password
        <span class="cov8" title="1">hashedPassword, err := auth.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to process password"})
        }</span>

        // Create user
        <span class="cov8" title="1">user := &amp;models.User{
                Email:    req.Email,
                Password: hashedPassword,
                Name:     req.Name,
                Role:     "user", // Default role
                IsActive: true,
        }

        if err := h.userRepo.CreateUser(user); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to create user"})
        }</span>

        // Generate JWT token
        <span class="cov8" title="1">token, err := h.jwtManager.GenerateToken(strconv.Itoa(int(user.ID)), user.Role, 24*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to generate token"})
        }</span>

        <span class="cov8" title="1">response := RegisterResponse{
                User: UserResponse{
                        ID:       user.ID,
                        Email:    user.Email,
                        Name:     user.Name,
                        Role:     user.Role,
                        IsActive: user.IsActive,
                },
                Token: token,
        }

        return c.JSON(http.StatusCreated, response)</span>
}

// Login handles user authentication
func (h *AuthHandler) Login(c echo.Context) error <span class="cov8" title="1">{
        var req LoginRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request format"})
        }</span>

        // Validate input
        <span class="cov8" title="1">if err := h.validateLoginRequest(req); err != nil </span><span class="cov8" title="1">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: err.Error()})
        }</span>

        // Get user by email
        <span class="cov8" title="1">user, err := h.userRepo.GetUserByEmail(req.Email)
        if err != nil </span><span class="cov8" title="1">{
                return c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid credentials"})
        }</span>

        // Check password
        <span class="cov8" title="1">if !auth.CheckPassword(req.Password, user.Password) </span><span class="cov8" title="1">{
                return c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid credentials"})
        }</span>

        // Generate JWT token
        <span class="cov8" title="1">token, err := h.jwtManager.GenerateToken(strconv.Itoa(int(user.ID)), user.Role, 24*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to generate token"})
        }</span>

        <span class="cov8" title="1">response := LoginResponse{
                User: UserResponse{
                        ID:       user.ID,
                        Email:    user.Email,
                        Name:     user.Name,
                        Role:     user.Role,
                        IsActive: user.IsActive,
                },
                Token: token,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetProfile returns the current user's profile
func (h *AuthHandler) GetProfile(c echo.Context) error <span class="cov8" title="1">{
        // Get user from context (set by JWT middleware)
        userClaims, ok := auth.GetCurrentUser(c)
        if !ok </span><span class="cov8" title="1">{
                return c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "User not authenticated"})
        }</span>

        // Convert user ID from string to uint
        <span class="cov8" title="1">userID, err := strconv.ParseUint(userClaims.UserID, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid user ID"})
        }</span>

        // Get user from database
        <span class="cov8" title="1">user, err := h.userRepo.GetUserByID(uint(userID))
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, ErrorResponse{Error: "User not found"})
        }</span>

        <span class="cov8" title="1">response := UserResponse{
                ID:       user.ID,
                Email:    user.Email,
                Name:     user.Name,
                Role:     user.Role,
                IsActive: user.IsActive,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// RefreshToken generates a new token from an existing valid token
func (h *AuthHandler) RefreshToken(c echo.Context) error <span class="cov8" title="1">{
        var req RefreshTokenRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request format"})
        }</span>

        // Refresh the token
        <span class="cov8" title="1">newToken, err := h.jwtManager.RefreshToken(req.Token, 24*time.Hour)
        if err != nil </span><span class="cov8" title="1">{
                return c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid or expired token"})
        }</span>

        <span class="cov8" title="1">response := RefreshTokenResponse{
                Token: newToken,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// Helper functions for validation
func (h *AuthHandler) validateRegisterRequest(req RegisterRequest) error <span class="cov8" title="1">{
        if req.Email == "" </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "Email is required")
        }</span>

        <span class="cov8" title="1">if !h.isValidEmail(req.Email) </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid email format")
        }</span>

        <span class="cov8" title="1">if req.Name == "" </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "Name is required")
        }</span>

        <span class="cov8" title="1">if len(req.Name) &lt; 2 </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Name must be at least 2 characters long")
        }</span>

        // Validate password strength
        <span class="cov8" title="1">if err := auth.ValidatePasswordStrength(req.Password); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (h *AuthHandler) validateLoginRequest(req LoginRequest) error <span class="cov8" title="1">{
        if req.Email == "" </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "Email is required")
        }</span>

        <span class="cov8" title="1">if req.Password == "" </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, "Password is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (h *AuthHandler) isValidEmail(email string) bool <span class="cov8" title="1">{
        emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        return emailRegex.MatchString(email)
}</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "log"
        "os"

        "classsphere-backend/auth"
        "classsphere-backend/cache"
        "classsphere-backend/config"
        "classsphere-backend/database"
        "classsphere-backend/handlers"
        "classsphere-backend/models"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg := config.Load()

        // Initialize database
        db, err := database.InitializeDatabase(cfg.DatabasePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize database: %v", err)
        }</span>

        // Initialize cache (for future use)
        <span class="cov0" title="0">redisClient := cache.NewRedisClient(cfg.RedisAddr, cfg.RedisPassword, cfg.RedisDB)
        _ = cache.NewRedisCache(redisClient) // Cache client ready for future features

        // Initialize JWT manager
        jwtManager := auth.NewJWTManager(cfg.JWTSecret)

        // Initialize repositories
        userRepo := models.NewUserRepository(db)

        // Initialize handlers
        authHandler := handlers.NewAuthHandler(userRepo, jwtManager)

        // Setup Echo
        e := echo.New()

        // Middleware
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())
        e.Use(middleware.CORS())

        // Public routes
        e.GET("/", handleWelcome)
        e.GET("/health", handleHealth)

        // Auth routes
        authGroup := e.Group("/auth")
        authGroup.POST("/register", authHandler.Register)
        authGroup.POST("/login", authHandler.Login)
        authGroup.POST("/refresh", authHandler.RefreshToken)

        // Protected routes
        protectedGroup := e.Group("/api")
        protectedGroup.Use(auth.JWTMiddleware(jwtManager))
        protectedGroup.GET("/profile", authHandler.GetProfile)

        // Admin routes (require admin role)
        adminGroup := e.Group("/admin")
        adminGroup.Use(auth.JWTMiddleware(jwtManager))
        adminGroup.Use(auth.RequireRole("admin"))
        // Add admin routes here later

        // Start server
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">log.Printf("Starting ClassSphere API server on port %s", port)
        e.Logger.Fatal(e.Start(":" + port))</span>
}

func handleWelcome(c echo.Context) error <span class="cov8" title="1">{
        return c.JSON(200, map[string]string{
                "message": "ClassSphere API",
                "version": "1.0.0",
                "status":  "running",
        })
}</span>

func handleHealth(c echo.Context) error <span class="cov8" title="1">{
        return c.JSON(200, map[string]string{
                "status":    "healthy",
                "service":   "classsphere-backend",
                "timestamp": "2025-10-06",
        })
}</span>

func setupTestApp() *echo.Echo <span class="cov8" title="1">{
        e := echo.New()
        e.GET("/", handleWelcome)
        e.GET("/health", handleHealth)
        return e
}</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// User represents a user in the system
type User struct {
        ID        uint           `json:"id" gorm:"primaryKey"`
        Email     string         `json:"email" gorm:"uniqueIndex;not null"`
        Password  string         `json:"-" gorm:"not null"` // JSON tag "-" excludes from JSON serialization
        Name      string         `json:"name" gorm:"not null"`
        Role      string         `json:"role" gorm:"not null;default:'user'"` // 'user', 'admin', 'instructor'
        IsActive  bool           `json:"is_active" gorm:"default:true"`
        CreatedAt time.Time      `json:"created_at"`
        UpdatedAt time.Time      `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"-" gorm:"index"` // Soft delete
}

// TableName sets the table name for GORM
func (User) TableName() string <span class="cov8" title="1">{
        return "users"
}</span>

// IsAdmin checks if the user has admin role
func (u *User) IsAdmin() bool <span class="cov8" title="1">{
        return u.Role == "admin"
}</span>

// IsInstructor checks if the user has instructor role
func (u *User) IsInstructor() bool <span class="cov8" title="1">{
        return u.Role == "instructor"
}</span>

// UserRepository handles database operations for users
type UserRepository struct {
        db *gorm.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *gorm.DB) *UserRepository <span class="cov8" title="1">{
        return &amp;UserRepository{db: db}
}</span>

// CreateUser creates a new user in the database
func (r *UserRepository) CreateUser(user *User) error <span class="cov8" title="1">{
        return r.db.Create(user).Error
}</span>

// GetUserByEmail retrieves a user by email
func (r *UserRepository) GetUserByEmail(email string) (*User, error) <span class="cov8" title="1">{
        var user User
        err := r.db.Where("email = ? AND is_active = ?", email, true).First(&amp;user).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// GetUserByID retrieves a user by ID
func (r *UserRepository) GetUserByID(id uint) (*User, error) <span class="cov8" title="1">{
        var user User
        err := r.db.Where("is_active = ?", true).First(&amp;user, id).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// UpdateUser updates an existing user
func (r *UserRepository) UpdateUser(user *User) error <span class="cov8" title="1">{
        // First check if the user exists
        var existingUser User
        err := r.db.First(&amp;existingUser, user.ID).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Update the user
        <span class="cov8" title="1">result := r.db.Save(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// DeleteUser soft deletes a user by ID
func (r *UserRepository) DeleteUser(id uint) error <span class="cov8" title="1">{
        result := r.db.Delete(&amp;User{}, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov8" title="1">{
                return gorm.ErrRecordNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListUsers retrieves users with pagination
func (r *UserRepository) ListUsers(offset, limit int) ([]*User, error) <span class="cov8" title="1">{
        var users []*User
        err := r.db.Where("is_active = ?", true).
                Offset(offset).
                Limit(limit).
                Order("created_at DESC").
                Find(&amp;users).Error
        return users, err
}</span>

// GetUserCount returns the total count of active users
func (r *UserRepository) GetUserCount() (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.Model(&amp;User{}).Where("is_active = ?", true).Count(&amp;count).Error
        return count, err
}</span>

// DeactivateUser deactivates a user instead of deleting
func (r *UserRepository) DeactivateUser(id uint) error <span class="cov0" title="0">{
        result := r.db.Model(&amp;User{}).Where("id = ?", id).Update("is_active", false)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return gorm.ErrRecordNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ActivateUser activates a deactivated user
func (r *UserRepository) ActivateUser(id uint) error <span class="cov0" title="0">{
        result := r.db.Model(&amp;User{}).Where("id = ?", id).Update("is_active", true)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return gorm.ErrRecordNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
